#separator:tab
#html:true
#deck column:3
#columns:Text	Back Extra	Deck
JWT is used as {{c1::the actual token carrying data::purpose}} (authentication, authorization tokens), while JWK is used as {{c2::the key format to sign/verify those tokens::purpose}}. Think of JWT as {{c3::the locked box::analogy}} and JWK as {{c4::the key::analogy}}.	Common JWT use cases: Bearer tokens in API requests, ID tokens in OIDC, refresh tokens, SSO tokens. JWK use cases: key storage format, publishing public keys at JWKS endpoints, key rotation infrastructure. You send JWTs to APIs, but JWKs verify them behind the scenes.	Web dev::!HIGH_PRIO::Auth & Permissions
In OAuth2/OIDC, {{c5::identity providers}} publish {{c1::public JWKs::what}} at {{c2::/.well-known/jwks.json::endpoint}} so clients can {{c3::verify JWT signatures::purpose}} without {{c4::hardcoding keys or sharing secrets::benefit}}.	This is the most common JWK use case in production. Example: Auth0 publishes JWKs at <code>https://your-tenant.auth0.com/.well-known/jwks.json</code>. Your app fetches this, matches the <code>kid</code> from JWT header to a JWK, and verifies the signature. No manual key management needed.	Web dev::!HIGH_PRIO::Auth & Permissions
JWK enables {{c1::key rotation without downtime::primary benefit}} by allowing multiple keys in {{c2::JWKS::collection}} identified by {{c3::kid::identifier}}. New JWTs use new keys while old JWTs remain valid with {{c4::old keys still published::backward compatibility}}.	Rotation flow: 1) Add new JWK to JWKS with new <code>kid</code>. 2) Start signing new JWTs with new key. 3) Keep old JWK for verifying existing tokens. 4) Remove old JWK after token expiration period. Client apps automatically fetch updated JWKS without code changes or redeployment.	Web dev::!HIGH_PRIO::Auth & Permissions
You directly work with JWKs when {{c1::building your own auth service::scenario 1}}, implementing {{c2::custom JWT signing/verification::scenario 2}}, or managing {{c3::key rotation infrastructure::scenario 3}}. Otherwise, you're {{c4::using JWKs indirectly::typical case}} through auth providers.	If you use Auth0/Okta/Firebase Auth/Clerk, they manage JWKs for you. Libraries like <code>jose</code> with <code>createRemoteJWKSet(url)</code> fetch and cache JWKs automatically. You only see JWTs in your application code, but JWKs are working behind the scenes.	Web dev::!HIGH_PRIO::Auth & Permissions
JWK format is superior to {{c1::PEM format::alternative}} for web APIs because it's {{c2::native JSON::format advantage}}, includes {{c3::metadata like kid and alg::built-in features}}, and enables {{c4::programmatic key discovery::discoverability}}.	PEM format requires parsing, doesn't include metadata, and needs out-of-band coordination for key identification. JWKs can be fetched via HTTP, parsed as JSON, and include everything needed: key type, algorithm, identifier, and key material. Perfect for REST APIs and microservices.	Web dev::!HIGH_PRIO::Auth & Permissions
When verifying a JWT, you {{c1::extract kid from JWT header::step 1}}, {{c2::fetch JWKS from the issuer::step 2}}, {{c3::find matching JWK by kid::step 3}}, then {{c4::verify signature with that JWK::step 4}}.	Example: JWT header <code>{"alg":"RS256","kid":"2024-01"}</code> → Fetch <code>https://idp.com/.well-known/jwks.json</code> → Find JWK where <code>kid === "2024-01"</code> → Import JWK as public key → Verify JWT signature. Libraries like jose automate this entire flow with <code>createRemoteJWKSet</code>.	Web dev::!HIGH_PRIO::Auth & Permissions
In multi-tenant systems, different tenants use {{c1::different JWKs identified by kid::isolation mechanism}} in the same {{c2::JWKS endpoint::shared infrastructure}}, allowing {{c3::tenant-specific key management::benefit}} while sharing {{c4::verification infrastructure::efficiency}}.	Example JWKS: <code>{"keys":[{"kid":"tenant-a-2024",...},{"kid":"tenant-b-2024",...}]}</code>. Each tenant's JWTs include their specific <code>kid</code>. The verification service uses the <code>kid</code> to select the correct JWK. Enables key rotation per tenant without affecting others.	Web dev::!HIGH_PRIO::Auth & Permissions
JWK's {{c1::kid (key ID)::field}} field enables {{c2::simultaneous use of multiple keys::primary purpose}}, which is essential for {{c3::zero-downtime key rotation::use case}} and {{c4::multi-tenant systems::use case}}.	Without <code>kid</code>, you couldn't tell which key signed which JWT. The <code>kid</code> in JWT header matches a <code>kid</code> in JWKS, enabling precise key selection. This allows old and new keys to coexist during rotation periods and different tenants to have separate keys in shared infrastructure.	Web dev::!HIGH_PRIO::Auth & Permissions
A real-world JWT verification flow: User logs in → receives {{c1::JWT with kid in header::token}}, API receives request → fetches {{c2::JWKS from IdP endpoint::keys}}, matches {{c3::kid to find correct JWK::selection}}, verifies {{c4::signature and claims::validation}}.	Complete example: 1) User logs into Auth0. 2) Auth0 returns JWT: <code>eyJraWQiOiIyMDI0LTAxIiwiYWxnIjoiUlMyNTYifQ...</code>. 3) Your API extracts <code>kid: "2024-01"</code>. 4) Fetches Auth0's JWKS. 5) Finds matching JWK. 6) Verifies signature. 7) Checks <code>exp</code>, <code>iss</code>, <code>aud</code> claims. 8) Trusts JWT if all valid.	Web dev::!HIGH_PRIO::Auth & Permissions
You're already using JWKs if you integrate with {{c1::OAuth2/OIDC providers::common case}} like {{c2::Auth0, Okta, Firebase, Clerk::examples}}, or use {{c3::libraries with JWKS fetching::implementation}} like {{c4::jose's createRemoteJWKSet::specific tool}}.	These providers automatically: 1) Generate JWK pairs. 2) Sign JWTs with private JWKs. 3) Publish public JWKs at well-known endpoints. 4) Handle key rotation. Your integration code uses JWKs behind the scenes even if you never see the actual JWK objects. The library fetches and caches them automatically.	Web dev::!HIGH_PRIO::Auth & Permissions