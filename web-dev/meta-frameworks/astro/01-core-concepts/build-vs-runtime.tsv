#separator:tab
#html:true
#deck column:3
#columns:Text	Back Extra	Deck
Astro processes pages at {{c1::build time::execution phase}} by default, generating static HTML files ahead of user requests.	Like Next.js SSG mode, pages are pre-rendered during <code>npm run build</code>. But unlike Next.js, this is the only mode by default unless you add an adapter for SSR. No Node.js server needed for static sites.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
Component frontmatter code in Astro executes {{c1::once per page::frequency}} during the build or server render, not on every user visit.	Data fetching with <code>await fetch()</code> happens at build time for static sites. The HTML result is cached and served to all users. In Next.js SSR, this would run on every request.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
To enable server-side rendering at runtime, you must add an {{c1::adapter::configuration requirement}} to your Astro config.	<code>import vercel from '@astrojs/vercel/serverless';<br>export default { adapter: vercel() }</code><br>Without an adapter, Astro only builds static sites. Next.js has server runtime built-in, Astro requires explicit opt-in.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
Setting <code>export const prerender = false</code> in a page component enables {{c1::on-demand server-side rendering::rendering mode}} for that specific page.	That page will be rendered at request time instead of build time, while other pages remain static. Similar to Next.js mixing SSG and SSR, but Astro's default is static whereas Next.js defaults to SSR in App Router.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
The Astro config option <code>output: 'static'</code> means {{c1::all pages are prerendered::build mode}} at build time by default.	This is the default setting. Every page becomes an HTML file. To enable SSR, change to <code>output: 'server'</code> or <code>output: 'hybrid'</code>. Next.js App Router defaults to SSR, requiring opt-in for static via <code>export const dynamic = 'force-static'</code>.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
The Astro config option <code>output: 'server'</code> enables {{c1::server-side rendering::rendering mode}} for all pages by default, with opt-in prerendering.	All pages are rendered on-demand at request time. Add <code>export const prerender = true</code> to specific pages to pre-render them at build time. This inverts the static default.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
The Astro config option <code>output: 'hybrid'</code> allows {{c1::mixing static and server-rendered pages::rendering mode}} in the same project with granular control.	Start with static default, add <code>export const prerender = false</code> to pages that need SSR. This is the most flexible mode, similar to Next.js App Router's per-page rendering choice.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
Build-time data fetching happens {{c1::once during build::execution timing}}, and the result is cached in static HTML files served to all users.	Great for content that doesn't change often like blog posts or product catalogs. API is called once at build time, not on every page view. Rebuild the site to update content. Next.js ISR offers timed revalidation as a middle ground.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
Runtime data fetching in server mode happens {{c1::on every request::execution timing}}, allowing dynamic content that updates without rebuilding.	Use for user-specific data, real-time content, or frequently changing information. Requires a server runtime (adapter). Similar to Next.js SSR or getServerSideProps, but Astro requires explicit opt-in.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
JavaScript in component frontmatter belongs to the {{c1::build/server stage::execution context}}, while client directive code belongs to the {{c2::runtime/browser stage::execution context}}.	Frontmatter runs once to generate HTML. Client directives send code to run repeatedly in browsers. Understanding this split is key to Astro's performance. React blurs this line, making it easier to accidentally ship server code to client.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
Build-time rendering is faster for users because {{c1::HTML is pre-generated::performance benefit}} and served from a CDN without server computation on each request.	Users get instant responses with zero server processing time. Best for content-driven sites. Trade-off is content updates require rebuilds. Next.js static export has the same benefits.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
Static sites built at build time can be deployed to {{c1::simple hosting::deployment options}} like GitHub Pages, Netlify, or Vercel without needing a Node.js server.	Just upload HTML/CSS/JS files to any web server. No runtime dependencies. Much simpler and cheaper than SSR which requires always-on servers. This is Astro's sweet spot for blogs and marketing sites.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
Astro's distinction between build-time and runtime ensures {{c1::server code never reaches the client::security benefit}}, preventing accidental exposure of secrets or heavy dependencies.	Build scripts run in a trusted environment. Only the HTML output goes to browsers. Next.js Server Components have a similar split, but Astro makes it more explicit with frontmatter vs template.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Build-vs-Runtime
