#separator:tab
#html:true
#deck column:3
#columns:Text	Back Extra	Deck
An Astro component consists of two main parts: the {{c1::component script::code section}} and the {{c2::component template::markup section}}.	The script goes between <code>---</code> fences (frontmatter) and handles logic. The template comes after and defines HTML output. Inspired by Markdown frontmatter, this separation is clearer than mixing logic and JSX in React.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
The component script in Astro is delimited by {{c1::three dashes (---) ::delimiter syntax}} at the top and bottom, called frontmatter.	<code>---<br>const greeting = "Hello";<br>---</code><br>This frontmatter concept comes from Markdown and static site generators, making it familiar to content creators. React doesn't have this separation.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
Component props in Astro are accessed via the {{c1::Astro.props::global object}} global and typically destructured in the frontmatter.	<code>const { title, author } = Astro.props;</code><br>Similar to React props but accessed through a global rather than function parameters. More explicit about the component's dependencies.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
JavaScript code in Astro component frontmatter executes {{c1::on the server::execution location}} and is {{c2::stripped from the final page::client impact}} sent to users.	All imports, data fetching, and computation in frontmatter runs server-side only. Unlike React components where imports become part of the client bundle, Astro frontmatter code never reaches the browser.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
Astro component templates use {{c1::JSX-like syntax::template language}} but are not exactly JSX.	You can use <code>{expressions}</code> and most JSX patterns, but className is <code>class</code>, and there are some differences. Closer to HTML than React JSX, making it more familiar to traditional web developers.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
In Astro frontmatter, you can use {{c1::top-level await::async feature}} without wrapping it in an async function.	<code>const data = await fetch(url).then(r => r.json());</code><br>This is more concise than React where you need useEffect or React Server Components with async functions. Data is fetched once during render, not on every state change.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
Astro components support {{c1::slots::composition feature}} for component composition, similar to children props in React.	Default slot receives children, named slots allow multiple content areas. <code>&lt;slot name="header" /&gt;</code> for named slots. More flexible than React's single children prop.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
To pass props to an Astro component, use {{c1::HTML-style attributes::syntax}} just like in JSX.	<code>&lt;GreetingCard title="Hello" name="World" /&gt;</code><br>Identical syntax to React/Next.js, making the transition easy. The difference is how props are accessed inside the component (via Astro.props).	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
Astro components can import and use {{c1::other Astro components::composition}} as well as framework components like React or Vue.	<code>import Header from './Header.astro';<br>import Button from './Button.jsx';</code><br>Mix and match freely. Astro components are always static, framework components can be static or interactive with client directives.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
Static Astro components serve the same role as {{c1::template files::traditional approach}} in PHP or Ruby on Rails, but with modern component syntax.	Think of them as server-side rendered templates that produce HTML. No client-side lifecycle, no useState, no effects. Simpler mental model for content-focused pages.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
Astro component frontmatter can access {{c1::environment variables, database APIs, and private credentials::server capabilities}} safely without exposing them to the client.	<code>const apiKey = import.meta.env.SECRET_API_KEY;</code><br>Since frontmatter never runs on client, secrets stay secure. In Next.js you must be careful about NEXT_PUBLIC_ vs server-only variables.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
Unlike React components that always include JavaScript, Astro components are {{c1::static by default::interactivity model}} and require explicit client directives for interactivity.	This inverted default makes Astro faster but less suitable for highly interactive UIs. Choose Astro components for static content, framework components when you need state, effects, or interactivity.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
Astro component props do not support {{c1::TypeScript interfaces::type definition}} directly in the component signature, but you can define them separately.	Create an interface, then destructure with type annotation: <code>const { title, author }: Props = Astro.props;</code> Less integrated than React's typed props but still type-safe.	Web dev::META FRAMEWORKS::Astro::01-Core-Concepts::Component-Based-Architecture
