#separator:tab
#html:true
#deck column:3
#columns:Text	Back Extra	Deck
In Astro, data fetching code is written in the component's {{c1::frontmatter::section name}}, between the triple dashes <code>---</code>.	The frontmatter executes at build time for static sites or at request time with SSR. Code here runs on the server, never in the browser. Similar to Next.js <code>getStaticProps</code> but written directly in the component file.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Data-Flow
Astro supports {{c1::top-level await::JavaScript feature}} in component frontmatter, allowing direct use of async operations without wrapping in an async function.	You can write <code>const data = await fetch(url)</code> directly in the frontmatter without needing an IIFE or separate async function. This is because the frontmatter is treated as an async context. Next.js requires <code>getStaticProps</code> to be async, but Astro's approach is more ergonomic.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Fetch-API
By default, Astro executes fetch calls at {{c1::build time::execution phase}}, and the fetched data becomes part of the static HTML output.	Each fetch runs once during <code>npm run build</code> and the result is cached in the generated HTML. Similar to Next.js SSG with <code>getStaticProps</code>. If you need runtime fetching, enable SSR mode with an adapter.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Caching-Performance
When SSR mode is enabled in Astro, fetch calls in frontmatter execute at {{c1::runtime::execution phase}} on each request, not at build time.	This requires an adapter (Node, Vercel, Netlify, etc.) and setting <code>output: 'server'</code> in config. Similar to Next.js <code>getServerSideProps</code> where data is fetched fresh on every request.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Caching-Performance
Data fetched in Astro frontmatter can be passed to child components as {{c1::props::data passing method}}, just like regular component properties.	Example: <code>&lt;Contact email={user.email} /&gt;</code>. Works with both Astro components and framework components (React, Vue, Svelte). The fetched data flows down from parent to child like any other prop.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Data-Flow
To query all entries from a content collection in Astro, use the {{c1::getCollection()::function name}} function from <code>astro:content</code>.	Example: <code>const posts = await getCollection('blog')</code> returns all entries from <code>src/content/blog/</code>. Returns an array of typed entries with <code>id</code>, <code>data</code> (frontmatter), and <code>body</code> properties. More type-safe than <code>import.meta.glob()</code>.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Content-Collections
To fetch a single entry from a content collection, use {{c1::getEntry()::function name}} with the collection name and entry ID.	Example: <code>const post = await getEntry('blog', 'post-1')</code>. Returns a single <code>CollectionEntry</code> object or undefined if not found. More efficient than <code>getCollection()</code> when you only need one item.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Content-Collections
The {{c1::getCollection()::function name}} function accepts an optional second parameter that is a filter function to narrow down results based on entry properties.	Example: <code>await getCollection('blog', ({ data }) =&gt; data.draft === true)</code> returns only draft posts. The filter receives each entry and returns a boolean. Useful for filtering by tags, dates, or custom frontmatter fields.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Content-Collections
Content collection entries returned by getCollection() have a {{c1::data::property name}} property that contains the validated frontmatter based on your schema.	If you define a schema with <code>defineCollection()</code>, the <code>data</code> property is fully typed. Without a schema, it defaults to <code>any</code>. This ensures type safety and validation for your content metadata.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Content-Collections
Collection entries have an {{c1::id::property name}} property that serves as a unique identifier, with all IDs from Astro's built-in loader being slugified.	Example: a file <code>my-post.md</code> has <code>id: 'my-post'</code>. This ID is used with <code>getEntry()</code> and for generating routes. Unlike the filename, it's always URL-safe.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Content-Collections
The {{c1::body::property name}} property of a collection entry contains the raw, uncompiled content of Markdown or MDX documents.	This is the actual content after the frontmatter, before rendering. You typically render it using the entry's <code>render()</code> function. Useful if you need to process or analyze the raw markdown.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Content-Collections
Collections returned by getCollection() have {{c1::non-deterministic::order characteristic}} sort order that varies by platform, so you must sort entries manually if order matters.	Example: <code>posts.sort((a, b) =&gt; b.data.date - a.data.date)</code> for newest first. Unlike Next.js which can sort during <code>getStaticProps</code>, Astro requires explicit sorting since file system order isn't guaranteed.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Content-Collections
To import multiple files at once in Astro, use {{c1::import.meta.glob()::Vite function}} with a glob pattern to match file paths.	Example: <code>import.meta.glob('./posts/*.md')</code>. This is a Vite feature, not Astro-specific. Returns an object where keys are file paths and values are import functions or modules. More flexible than content collections for non-content files.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Local-File-Access
The import.meta.glob() function only supports {{c1::static string literals::pattern type}} for glob patterns, not dynamic variables or string interpolation.	You cannot use <code>import.meta.glob(\`./\${dir}/*.md\`)</code>. Instead, import a broader set and filter afterward. This is a Vite limitation for build-time optimization and bundling.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Local-File-Access
To load all matched modules immediately when the application starts with import.meta.glob(), pass {{c1::{ eager: true }::option object}} as the second argument.	Example: <code>import.meta.glob('./posts/*.md', { eager: true })</code>. Without eager, imports are lazy and return Promise functions. With eager, you get actual module objects immediately. Eager is better for build-time SSG scenarios.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Local-File-Access
When using import.meta.glob() with <code>{ eager: true }</code> on markdown files, access the results using {{c1::Object.values()::method call}} to convert the object to an array.	Example: <code>const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }))</code>. The glob returns an object keyed by file paths, so you need <code>Object.values()</code> to get an array for mapping or filtering.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Local-File-Access
Markdown files imported via import.meta.glob() expose frontmatter data through a {{c1::frontmatter::property name}} property containing all YAML metadata from the file.	Example: <code>post.frontmatter.title</code>. Each imported markdown module is a <code>MarkdownInstance</code> object with <code>frontmatter</code>, <code>url</code>, <code>file</code>, and compiled content. This differs from content collections which use <code>data</code> instead of <code>frontmatter</code>.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Local-File-Access
In Astro's default {{c1::static::output mode}} mode, all pages are prerendered at build time and served as static HTML files.	Set in config: <code>output: 'static'</code>. This is the default. All fetch calls and data processing happen once during build. Similar to Next.js SSG. No server runtime needed for deployment.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Caching-Performance
In Astro's {{c1::server::output mode}} output mode, pages use server-side rendering and are rendered on-demand at request time by default.	Set in config: <code>output: 'server'</code>. Requires an adapter (Node, Vercel, Cloudflare, etc.). All fetch calls run on each request unless cached. Similar to Next.js <code>app</code> directory with dynamic rendering.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Caching-Performance
To disable prerendering for a specific page in Astro while keeping the rest of the site static, add {{c1::export const prerender = false::export statement}} in the frontmatter.	This opts the page into on-demand SSR even in static mode. Requires an adapter. Useful for pages with user-specific content or real-time data. Next.js equivalent is <code>export const dynamic = 'force-dynamic'</code> in app router.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Caching-Performance
Astro frontmatter code executes {{c1::once per build::frequency}} for static sites, meaning all users see the same fetched data until the next build.	The fetch happens during <code>npm run build</code> and results are embedded in HTML. To get fresh data, rebuild and redeploy. With SSR, code runs once per request instead. This is a key difference from client-side fetching which runs in each user's browser.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Caching-Performance
Unlike Next.js which separates data fetching into getStaticProps and getServerSideProps, Astro uses {{c1::the same frontmatter code::unified approach}} for both build-time and runtime fetching, with behavior controlled by output mode.	The same <code>await fetch()</code> code runs at build time in static mode or request time in server mode. This simplifies mental model - you write data fetching once and deploy mode determines execution timing.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Data-Flow
In Astro, fetched data in frontmatter can be rendered directly in the {{c1::HTML template::rendering location}} section below the frontmatter, without needing to return it from a function.	Example: <code>&lt;h1&gt;{user.name}&lt;/h1&gt;</code>. All frontmatter variables are automatically available in the template. Next.js requires returning from <code>getStaticProps</code> then accessing via <code>props</code>. Astro's approach is more direct.	Web dev::Meta Frameworks::Astro::04-Data-Fetching::Data-Flow
